<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 设计模式（二）：工厂方法模式]]></title>
    <url>%2F2018%2F12%2F30%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考链接：工厂方法模式-Factory Method Pattern 在介绍简单工厂模式时提到简单工厂模式存在一个很严重的问题，就是当系统中需要引入新产品时，如果静态工厂方法是通过传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？工厂方法模式应运而生，本文将介绍第二种工厂模式——工厂方法模式。 1. 模式概述定义：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。 工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。工厂方法模式结构如图所示：在工厂方法模式结构图中包含如下几个角色： Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类。 ConcreteProduct（具体产品）：实现抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。 Factory（抽象工厂）：抽象工厂是工厂方法模式的核心，是具体工厂的父类，声明工厂方法。 ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：1234public abstract class AbstractFactory &#123; public abstract Shape getShape();&#125; 2. 模式实现具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现工厂方法，不同的具体工厂可以创建不同的具体产品，其典型代码如下所示：1234567891011public class CircleFactory extends AbstractFactory &#123; /** * 返回具体的 Circle 实例 * @return */ @Override public Shape getShape() &#123; return new Circle(); &#125;&#125; 1234567891011public class RectangleFactory extends AbstractFactory &#123; /** * 返回具体的 Rectangle 实例 * @return */ @Override public Shape getShape() &#123; return new Rectangle(); &#125;&#125; 1234567891011public class SquareFactory extends AbstractFactory &#123; /** * 返回具体的 Square 实例 * @return */ @Override public Shape getShape() &#123; return new Square(); &#125;&#125; 在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。 在客户端代码中，只需关心工厂类即可，不同的具体工厂可以创建不同的产品，典型的客户端类代码片段如下所示：123456789public class Client &#123; public static void main(String[] args) &#123; AbstractFactory factory; factory = new CircleFactory(); Shape circle = factory.getShape(); circle.draw(); &#125;&#125; 3. 方案改进可以通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。 在客户端代码中将不再使用new关键字来创建工厂对象，而是将具体工厂类的类名存储在配置文件（如XML文件）中，通过读取配置文件获取类名字符串，再使用Java的反射机制，根据类名字符串生成对象。 在配置文件config.xml用于存储具体日志记录器工厂类类名：12345&lt;?xml version="1.0"?&gt;&lt;config&gt; &lt;!-- 具体工厂类的全限定名 包名+类名 --&gt; &lt;className&gt;RectangleFactory&lt;/className&gt;&lt;/config&gt; 创建XMLUtil类读取该配置文件并通过存储在其中的类名字符串反射生成对象，其详细代码如下：123456789101112131415161718192021222324public class XMLUtil &#123; public static Object getFactory() &#123; try &#123; DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File("config.xml")); NodeList nl = doc.getElementsByTagName("className"); Node classNode = nl.item(0).getFirstChild(); String className = classNode.getNodeValue(); Class clazz = Class.forName(className); Object obj = clazz.newInstance(); return obj; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 要更换具体工厂时，通过XMLUtil类的静态方法getFactory()方法读取配置文件中的工厂类名进行对象的实例化，代码修改如下： 123456789public class Client &#123; public static void main(String[] args) &#123; AbstractFactory factory; factory = (AbstractFactory) XMLUtil.getFactory(); Shape shape = factory.getShape(); shape.draw(); &#125;&#125; 重载抽象工厂类的工厂方法可以实现多种方式初始化具体产品类，例如提供无参数的默认实现，还可以提供包含一个字符串参数的实现。 12345678public abstract class AbstractFactory &#123; public abstract Shape getShape(); public abstract Shape getShape(String args); public abstract Shape getShape(Object obj);&#125; 具体的工厂类实现重载的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同产品对象的需求。 4. 模式总结工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。 1.主要优点(1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节。(2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。(3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 2.主要缺点(1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度。(2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。 3.适用场景(1) 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件中。(2) 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 5. 思考有人说：可以在客户端代码中直接通过反射机制来生成产品对象，在定义产品对象时使用抽象类型，同样可以确保系统的灵活性和可扩展性，增加新的具体产品类无须修改源代码，只需要将其作为抽象产品类的子类再修改配置文件即可，根本不需要抽象工厂类和具体工厂类。 试思考这种做法的可行性？如果可行，这种做法是否存在问题？为什么？]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（一）：简单工厂模式]]></title>
    <url>%2F2018%2F12%2F30%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考链接：简单工厂模式-Simple Factory Pattern 1. 模式概述定义：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态方法，因此简单工厂模式又被称为静态工厂方法模式。 简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下：首先将需要创建的各种不同对象（例如各种不同的Shape对象）的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。 简单工厂模式结构比较简单，其核心是工厂类的设计，其结构如图所示： 在简单工厂模式中包含如下几个角色： Factory（工厂类）：负责实现创建所有产品实例的内部逻辑，在工厂类中提供静态的工厂方法，返回抽象产品。 Product（抽象产品）：所有具体产品的父类，封装各种产品对象的共有方法。 ConcreteProduct（具体产品类）：工厂类的创建目标。 2. 模式实现在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象。 在使用简单工厂模式时，首先需要对产品类进行重构，根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：12345678public abstract class Shape &#123; // 公共方法 public void show() &#123; &#125; // 抽象方法 public abstract void draw();&#125; 具体产品类继承抽象产品类并实现抽象方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示： 1234567public class Circle extends Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 1234567public class Rectangle extends Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; 1234567public class Square extends Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; 简单工厂模式的核心工厂类负责创建产品，提供一个静态工厂方法给客户端使用，典型的工厂类代码如下所示： 12345678910111213141516public class ShapeFactory &#123; public static Shape getShape(String shapeType) &#123; if (shapeType == null) &#123; return null; &#125; if (shapeType.equalsIgnoreCase("CIRCLE")) &#123; return new Circle(); &#125; else if (shapeType.equalsIgnoreCase("RECTANGLE")) &#123; return new Rectangle(); &#125; else if (shapeType.equalsIgnoreCase("SQUARE")) &#123; return new Square(); &#125; return null; &#125;&#125; 在客户端代码中，我们通过传入不同的参数给工厂方法来创建对应的产品，典型的代码如下所示： 12345678910111213public class Client &#123; public static void main(String[] args) &#123; Shape rectangle = ShapeFactory.getShape("Rectangle"); rectangle.draw(); Shape circle = ShapeFactory.getShape("Circle"); circle.draw(); Shape square = ShapeFactory.getShape("Square"); square.draw(); &#125;&#125; 3. 方案改进当我们更换一个Shape对象都需要修改客户端代码中静态工厂方法的参数，客户端代码将要重新编译，这对于客户端而言，违反了“开闭原则”，有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？ 我们可以将静态工厂方法的参数存储在XML或properties格式的配置文件中，如下config.xml所示：1234&lt;?xml version="1.0"?&gt;&lt;config&gt; &lt;chartType&gt;square&lt;/chartType&gt;&lt;/config&gt; 在通过一个工具类XMLUtil来读取配置文件中的字符串参数，XMLUtil类的代码如下所示： 123456789101112131415161718192021public class XMLUtil &#123; public static String getChartType() &#123; try &#123; // 创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; // config.xml的路径 doc = builder.parse(new File("config.xml")); // 获取包含图表类型的文本节点 NodeList nl = doc.getElementsByTagName("shapeType"); Node classNode = nl.item(0).getFirstChild(); String shapeType = classNode.getNodeValue().trim(); return shapeType; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 客户端通过读取配置文件中的shapeType创建对应的产品，客户端修改代码如下：12345678public class Client &#123; public static void main(String[] args) &#123; String shapeType = XMLUtil.getChartType(); Shape shape = ShapeFactory.getShape(shapeType); shape.draw(); &#125;&#125; 优化之后，如果需要更换具体图表对象，只需修改配置文件config.xml，无须修改任何源代码，符合“开闭原则”。 还有另外一种情况，当系统中需要引入新产品时，比如引入新产品Triangle，由于静态工厂方法通过所传入参数的不同来创建不同的产品，那么势必要在工厂类中新增一个if…else判断来返回Triangle实例，违背了“开闭原则”。 在工厂类中新增if…else判断的代码如下：123456789101112131415161718public class ShapeFactory &#123; public static Shape getShape(String shapeType) &#123; if (shapeType == null) &#123; return null; &#125; if (shapeType.equalsIgnoreCase("CIRCLE")) &#123; return new Circle(); &#125; else if (shapeType.equalsIgnoreCase("RECTANGLE")) &#123; return new Rectangle(); &#125; else if (shapeType.equalsIgnoreCase("SQUARE")) &#123; return new Square(); &#125; else if (shapeType.equalsIgnoreCase("TRIANGLE")) &#123; return new Triangle(); &#125; return null; &#125;&#125; 一旦产品类型较多时，工厂类会变得不易维护。 我们可以通过反射机制解加增加新产品时需要改动静态工厂方法的缺点，修改静态工厂方法代码如下：123456789public static &lt;T&gt; T getClass(Class&lt;? extends T&gt; clazz) &#123; T obj = null; try &#123; obj = (T) Class.forName(clazz.getName()).newInstance(); &#125; catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return obj;&#125; 对应的客户端通过传入具体的产品类创建不同的产品，客户端代码修改如下：1234567public class Client &#123; public static void main(String[] args) &#123; String shape = ShapeFactory.getClass(Circle.class); shape.draw(); &#125;&#125; 反射机制可以结合配置文件来更换具体的产品对象，而不需要改动客户端代码。 4. 模式总结简单工厂模式提供专门的工厂类用于创建对象，将对象的创建和对象的使用分离开。 1.主要优点(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 2.主要缺点(1) 由于工厂类集中了所有产品的创建逻辑，如果工厂类不能工作，整个系统都要受到影响。(2) 当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码（反射方式除外）。(3) 在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 3.适用场景(1) 工厂类负责创建的对象比较少时，不会造成工厂方法中的业务逻辑太过复杂，这个时候可以考虑使用简单工厂。(2) 客户端对于如何创建对象并不关心。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F12%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是设计模式设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。 面向对象设计的原则 开闭原则 (Open Close Principle) 里氏代换原则 (Liskov Substitution Principle) 依赖倒转原则 (Dependence Inversion Principle) 接口隔离原则 (Interface Segregation Principle) 单一职责原则 (Single Responsibility Principle) 4. 模式分类4.1 创建型模式 创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。 创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。 简单工厂模式 (Simple Factory Pattern)工厂方法模式 (Factory Method Pattern)抽象工厂模式 (Abstract Factory Pattern)建造者模式 (Builder Pattern)单例模式 (Singleton Pattern)原型模式 (Prototype Pattern) 4.2 结构型模式 结构型模式描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。 结构型模式可以分为类结构型模式和对象结构型模式：类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系；对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。 适配器模式 (Adapter Pattern)桥接模式 (Bridge Pattern)装饰模式 (Decorator Pattern)过滤器模式 (Filter Pattern)外观模式 (Facade Pattern)享元模式 (Flyweight Pattern)代理模式 (Proxy Pattern)组合模式 (Composite Pattern) 4.3 行为型模式 行为型模式是对在不同的对象之间划分责任和算法的抽象化。 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 行为型模式分为类行为型模式和对象行为型模式两种：类行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责；对象行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。 命令模式 (Command Pattern)中介者模式 (Mediator Pattern)观察者模式 (Observer Pattern)状态模式 (State Pattern)策略模式 (Strategy Pattern)责任链模式 (Chain of Responsibility Pattern)解释器模式 (Interpreter Pattern)迭代器模式 (Iterator Pattern)备忘录模式 (Memento Pattern) 5. GitHub 地址design-patterns]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 循环遍历中删除元素问题二]]></title>
    <url>%2F2018%2F11%2F14%2FArrayList%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E9%97%AE%E9%A2%98%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[前言问题一可以看我之前写的博客 List 循环遍历中删除元素问题一。 问题讲解问题二主要讲的是博主在今天的开发中遇到的一个问题。先来看下是什么问题让博主继上次问题后又写了问题二。 问题一中讲到通过Iterator的remove方法解决链表中循环删除元素的问题。来看下简单的代码： 123456789101112131415161718192021public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("1"); list.add("2"); list.add("3"); list.add("4"); list.add("5"); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; String s = iterator.next(); if ("4".equals(s)) &#123; iterator.remove(); &#125; &#125; System.out.println("list:" + list); &#125;&#125; 输出：list:[1, 2, 3, 5]，成功删除元素4。 但是这种解决方法中隐藏着一个坑。在今天和前端的联调过程中发现的，我们一般从数据库查询多条数据时会返回返回List&lt;?&gt;，?表示具体的实体类，然后通过Iterator遍历List删除其中的元素，以下是类似的代码： 12345678910111213141516public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("1","2","3","4","5"); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; String s = iterator.next(); if ("4".equals(s)) &#123; iterator.remove(); &#125; &#125; System.out.println("list:" + list); &#125;&#125; 原本以为通过iterator.remove()方法能够成功删除元素，但是上述代码在控制台却报了这么一个错： 1234Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.AbstractList.remove(AbstractList.java:161) at java.util.AbstractList$Itr.remove(AbstractList.java:374) at list.ListTest.main(ListTest.java:22) 一开始感到很困惑，但是在经过自己debug之后终于发现了问题所在，debug下进入的第一个方法： 123456789101112131415public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125;&#125; 在执行到AbstractList.this.remove(lastRet);时进入下一个方法： 12345678public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; /*... 其它方法略...*/ public E remove(int index) &#123; throw new UnsupportedOperationException(); &#125;&#125; 原来此处的ArrayList是一个实现了AbstractList的内部类，并且没有覆盖add和remove方法，默认这2个方法是会直接报“UnsupportedOperationException”的。 知道问题原因后，解决方法也就明确了。 1234567891011121314151617public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("1","2","3","4","5"); List&lt;String&gt; result= new ArrayList&lt;&gt;(list); Iterator&lt;String&gt; iterator = result.iterator(); while (iterator.hasNext()) &#123; String s = iterator.next(); if ("4".equals(s)) &#123; iterator.remove(); &#125; &#125; System.out.println("list:" + result); &#125;&#125; 通过将list拷贝到一个新的ArrayList中即可解决问题二。 总结在设计一个对外方法的时候，一点要谨慎处理集合和数组。因为你永远不知道传给你的集合是什么，也不知道是否会有对此集合有任何其他的不可控的操作。所以在使用客户端传递的集合对象时，最好拷贝一个新集合后再操作。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 循环遍历中删除元素问题一]]></title>
    <url>%2F2018%2F11%2F07%2FArrayList%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E9%97%AE%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[问题抛出一个ArrayList在循环过程中删除，会不会出问题，为什么？接下来给大家详细解释一下在这个过程中会出现的问题和原因及解决方法。 问题讲解ArrayList中的remove方法（注意ArrayList中的remove有两个同名方法，只是输入参数不同，这里看的是输入参数是Object的remove方法）是怎么实现的： 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; 12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work &#125; 执行System.arraycopy方法，导致删除元素时涉及到数组元素的移动。 for each写法是对实际的Iterator、hasNext、next方法的简写，问题出在上文的fastRemove中，可以看到第一行把modCount变量的值加1，但在ArrayList返回的迭代器（该代码在其父类AbstractList中）。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; 这里返回的是AbstractList类内部的迭代器实现private class Itr implements Iterator，看这个类的next方法。 1234567891011public E next() &#123; checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; 这里会做迭代器内部修改次数检查，因为你上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。要避免这种情况的出现，则在使用迭代器迭代时（显式或for each的隐式）不要使用ArrayList的remove，改用Iterator的remove即可。 总结错误原因都是ArrayList集合中remove方法底层的源码中有一个fastRemove(index)方法，然后会有一个modCount++的操作，然后在ArratList内部的迭代器中有一个checkForComodification操作，也就是检查modCount是否改变，如果改变了，就抛出并发修改错误。同样的在For each增强for循环中，也是利用了ArrayList自身的Iterator迭代器，也是会出现这样的错误。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 传值和传引用的区别]]></title>
    <url>%2F2018%2F11%2F05%2F%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言首先对传值和传引用要有个基本的概念 传值：传递的是值的副本。方法中对副本的修改，不会影响到调用方。 传引用：传递的是引用的副本，共用一个内存，会影响到调用方。此时，形参和实参指向同一个内存地址。对引用副本本身（对象地址）的修改，如设置为null，重新指向其他对象，不会影响到调用方。 实战直接上代码，更好的理解两者的区别。首先看传基本数据类型，如int、long等。123456789101112// 基本数据类型public class ParamChangeValue &#123; public static void main(String[] args) &#123; int s = 1; System.out.println("args = [" + s + "]"); change(s); System.out.println("args = [" + s + "]"); &#125; private static void change(int i)&#123; i = i* 5; &#125;&#125; 输出：args = [1]args = [1] 从输出的的结果中可以看到原本的s并没有被修改，即传值传递的是值的副本，不会影响到本身。 再来看传对象。1234567891011121314151617181920212223242526// 对象public class ObjectChangeValue &#123; public static class Score&#123; private int value; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125; &#125; public static void main(String[] args) &#123; Score score = new Score(); score.setValue(1); System.out.println("args = [" + score.getValue() + "]"); change(score); System.out.println("after args = [" + score.getValue() + "]"); &#125; private static void change(Score score)&#123; score.setValue(2); &#125;&#125; 输出：args = [1]after args = [2] 从结果中我们可以看到score实例的value值被修改了，因为传引用后指向的是同一个地址，修改的实际上也就是这个地址上的值，另外要注意一点的是如果对象被重新创建或赋值为null，即new会重新指向其他对象，不影响其原对象的值。 第三部分：传String、Integer等immutable类型。12345678910111213// String、Integer、Long等public class StringChangeValue &#123; public static void main(String[] args) &#123; String s = "test1"; System.out.println("args = [" + s + "]"); change(s); System.out.println("args = [" + s + "]"); &#125; private static void change(String i)&#123; i = i + " test value"; &#125;&#125; 输出：args = [test1]args = [test1] 只要知道String、Integer类是final类型的就明白输出的结果为什么是这样的。 总结基本类型（byte,short,int,long,double,float,char,boolean）为传值；对象类型（Object，数组，容器）为传引用；String、Integer、Double等immutable类型因为类的变量设为final属性，无法被修改，只能重新赋值或生成对象。当Integer作为方法参数传递时，对其赋值会导致原有的引用被指向了方法内的栈地址，失去原有的的地址指向，所以对赋值后的Integer做任何操作都不会影响原有值。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo教程</tag>
      </tags>
  </entry>
</search>
