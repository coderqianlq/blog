<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F12%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是设计模式设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。 面向对象设计的原则 开闭原则 (Open Close Principle) 里氏代换原则 (Liskov Substitution Principle) 依赖倒转原则 (Dependence Inversion Principle) 接口隔离原则 (Interface Segregation Principle) 单一职责原则 (Single Responsibility Principle) 4. 模式分类4.1 创建型模式创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。 创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。 简单工厂模式 (Simple Factory Pattern)工厂方法模式 (Factory Method Pattern)抽象工厂模式 (Abstract Factory Pattern)建造者模式 (Builder Pattern)单例模式 (Singleton Pattern)原型模式 (Prototype Pattern) 4.2 结构型模式结构型模式描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。 结构型模式可以分为类结构型模式和对象结构型模式：类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系；对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。 适配器模式 (Adapter Pattern)桥接模式 (Bridge Pattern)装饰模式 (Decorator Pattern)过滤器模式 (Filter Pattern)外观模式 (Facade Pattern)享元模式 (Flyweight Pattern)代理模式 (Proxy Pattern)组合模式 (Composite Pattern) 4.3 行为型模式行为型模式是对在不同的对象之间划分责任和算法的抽象化。 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 行为型模式分为类行为型模式和对象行为型模式两种：类行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责；对象行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。 命令模式 (Command Pattern)中介者模式 (Mediator Pattern)观察者模式 (Observer Pattern)状态模式 (State Pattern)策略模式 (Strategy Pattern)责任链模式 (Chain of Responsibility Pattern)解释器模式 (Interpreter Pattern)迭代器模式 (Iterator Pattern)备忘录模式 (Memento Pattern) 5. GitHub 地址design-patterns]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 循环遍历中删除元素问题二]]></title>
    <url>%2F2018%2F11%2F14%2FArrayList%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E9%97%AE%E9%A2%98%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[前言问题一可以看我之前写的博客 List 循环遍历中删除元素问题一。 问题讲解问题二主要讲的是博主在今天的开发中遇到的一个问题。先来看下是什么问题让博主继上次问题后又写了问题二。 问题一中讲到通过Iterator的remove方法解决链表中循环删除元素的问题。来看下简单的代码： 123456789101112131415161718192021public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("1"); list.add("2"); list.add("3"); list.add("4"); list.add("5"); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; String s = iterator.next(); if ("4".equals(s)) &#123; iterator.remove(); &#125; &#125; System.out.println("list:" + list); &#125;&#125; 输出：list:[1, 2, 3, 5]，成功删除元素4。 但是这种解决方法中隐藏着一个坑。在今天和前端的联调过程中发现的，我们一般从数据库查询多条数据时会返回返回List&lt;?&gt;，?表示具体的实体类，然后通过Iterator遍历List删除其中的元素，以下是类似的代码： 12345678910111213141516public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("1","2","3","4","5"); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; String s = iterator.next(); if ("4".equals(s)) &#123; iterator.remove(); &#125; &#125; System.out.println("list:" + list); &#125;&#125; 原本以为通过iterator.remove()方法能够成功删除元素，但是上述代码在控制台却报了这么一个错： 1234Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.AbstractList.remove(AbstractList.java:161) at java.util.AbstractList$Itr.remove(AbstractList.java:374) at list.ListTest.main(ListTest.java:22) 一开始感到很困惑，但是在经过自己debug之后终于发现了问题所在，debug下进入的第一个方法： 123456789101112131415public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125;&#125; 在执行到AbstractList.this.remove(lastRet);时进入下一个方法： 12345678public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; /*... 其它方法略...*/ public E remove(int index) &#123; throw new UnsupportedOperationException(); &#125;&#125; 原来此处的ArrayList是一个实现了AbstractList的内部类，并且没有覆盖add和remove方法，默认这2个方法是会直接报“UnsupportedOperationException”的。 知道问题原因后，解决方法也就明确了。 1234567891011121314151617public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("1","2","3","4","5"); List&lt;String&gt; result= new ArrayList&lt;&gt;(list); Iterator&lt;String&gt; iterator = result.iterator(); while (iterator.hasNext()) &#123; String s = iterator.next(); if ("4".equals(s)) &#123; iterator.remove(); &#125; &#125; System.out.println("list:" + result); &#125;&#125; 通过将list拷贝到一个新的ArrayList中即可解决问题二。 总结在设计一个对外方法的时候，一点要谨慎处理集合和数组。因为你永远不知道传给你的集合是什么，也不知道是否会有对此集合有任何其他的不可控的操作。所以在使用客户端传递的集合对象时，最好拷贝一个新集合后再操作。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 循环遍历中删除元素问题一]]></title>
    <url>%2F2018%2F11%2F07%2FArrayList%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E9%97%AE%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[问题抛出一个ArrayList在循环过程中删除，会不会出问题，为什么？接下来给大家详细解释一下在这个过程中会出现的问题和原因及解决方法。 问题讲解ArrayList中的remove方法（注意ArrayList中的remove有两个同名方法，只是输入参数不同，这里看的是输入参数是Object的remove方法）是怎么实现的： 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; 12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work &#125; 执行System.arraycopy方法，导致删除元素时涉及到数组元素的移动。 for each写法是对实际的Iterator、hasNext、next方法的简写，问题出在上文的fastRemove中，可以看到第一行把modCount变量的值加1，但在ArrayList返回的迭代器（该代码在其父类AbstractList中）。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; 这里返回的是AbstractList类内部的迭代器实现private class Itr implements Iterator，看这个类的next方法。 1234567891011public E next() &#123; checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; 这里会做迭代器内部修改次数检查，因为你上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。要避免这种情况的出现，则在使用迭代器迭代时（显式或for each的隐式）不要使用ArrayList的remove，改用Iterator的remove即可。 总结错误原因都是ArrayList集合中remove方法底层的源码中有一个fastRemove(index)方法，然后会有一个modCount++的操作，然后在ArratList内部的迭代器中有一个checkForComodification操作，也就是检查modCount是否改变，如果改变了，就抛出并发修改错误。同样的在For each增强for循环中，也是利用了ArrayList自身的Iterator迭代器，也是会出现这样的错误。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 传值和传引用的区别]]></title>
    <url>%2F2018%2F11%2F05%2F%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言首先对传值和传引用要有个基本的概念 传值：传递的是值的副本。方法中对副本的修改，不会影响到调用方。 传引用：传递的是引用的副本，共用一个内存，会影响到调用方。此时，形参和实参指向同一个内存地址。对引用副本本身（对象地址）的修改，如设置为null，重新指向其他对象，不会影响到调用方。 实战直接上代码，更好的理解两者的区别。首先看传基本数据类型，如int、long等。123456789101112// 基本数据类型public class ParamChangeValue &#123; public static void main(String[] args) &#123; int s = 1; System.out.println("args = [" + s + "]"); change(s); System.out.println("args = [" + s + "]"); &#125; private static void change(int i)&#123; i = i* 5; &#125;&#125; 输出：args = [1]args = [1] 从输出的的结果中可以看到原本的s并没有被修改，即传值传递的是值的副本，不会影响到本身。 再来看传对象。1234567891011121314151617181920212223242526// 对象public class ObjectChangeValue &#123; public static class Score&#123; private int value; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125; &#125; public static void main(String[] args) &#123; Score score = new Score(); score.setValue(1); System.out.println("args = [" + score.getValue() + "]"); change(score); System.out.println("after args = [" + score.getValue() + "]"); &#125; private static void change(Score score)&#123; score.setValue(2); &#125;&#125; 输出：args = [1]after args = [2] 从结果中我们可以看到score实例的value值被修改了，因为传引用后指向的是同一个地址，修改的实际上也就是这个地址上的值，另外要注意一点的是如果对象被重新创建或赋值为null，即new会重新指向其他对象，不影响其原对象的值。 第三部分：传String、Integer等immutable类型。12345678910111213// String、Integer、Long等public class StringChangeValue &#123; public static void main(String[] args) &#123; String s = "test1"; System.out.println("args = [" + s + "]"); change(s); System.out.println("args = [" + s + "]"); &#125; private static void change(String i)&#123; i = i + " test value"; &#125;&#125; 输出：args = [test1]args = [test1] 只要知道String、Integer类是final类型的就明白输出的结果为什么是这样的。 总结基本类型（byte,short,int,long,double,float,char,boolean）为传值；对象类型（Object，数组，容器）为传引用；String、Integer、Double等immutable类型因为类的变量设为final属性，无法被修改，只能重新赋值或生成对象。当Integer作为方法参数传递时，对其赋值会导致原有的引用被指向了方法内的栈地址，失去原有的的地址指向，所以对赋值后的Integer做任何操作都不会影响原有值。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo教程</tag>
      </tags>
  </entry>
</search>
