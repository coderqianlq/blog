<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ArrayList 循环遍历中删除元素问题]]></title>
    <url>%2F2018%2F11%2F07%2FArrayList%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题抛出一个ArrayList在循环过程中删除，会不会出问题，为什么？接下来给大家详细解释一下在这个过程中会出现的问题和原因及解决方法。 问题讲解ArrayList中的remove方法（注意ArrayList中的remove有两个同名方法，只是输入参数不同，这里看的是输入参数是Object的remove方法）是怎么实现的： 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; 12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work &#125; 执行System.arraycopy方法，导致删除元素时涉及到数组元素的移动。 for each写法是对实际的Iterator、hasNext、next方法的简写，问题出在上文的fastRemove中，可以看到第一行把modCount变量的值加1，但在ArrayList返回的迭代器（该代码在其父类AbstractList中）。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; 这里返回的是AbstractList类内部的迭代器实现private class Itr implements Iterator，看这个类的next方法。 1234567891011public E next() &#123; checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; 这里会做迭代器内部修改次数检查，因为你上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。要避免这种情况的出现，则在使用迭代器迭代时（显式或for each的隐式）不要使用ArrayList的remove，改用Iterator的remove即可。 总结错误原因都是ArrayList集合中remove方法底层的源码中有一个fastRemove(index)方法，然后会有一个modCount++的操作，然后在ArratList内部的迭代器中有一个checkForComodification操作，也就是检查modCount是否改变，如果改变了，就抛出并发修改错误。同样的在For each增强for循环中，也是利用了ArrayList自身的Iterator迭代器，也是会出现这样的错误。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 传值和传引用的区别]]></title>
    <url>%2F2018%2F11%2F05%2F%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言首先对传值和传引用要有个基本的概念 传值：传递的是值的副本。方法中对副本的修改，不会影响到调用方。 传引用：传递的是引用的副本，共用一个内存，会影响到调用方。此时，形参和实参指向同一个内存地址。对引用副本本身（对象地址）的修改，如设置为null，重新指向其他对象，不会影响到调用方。 实战直接上代码，更好的理解两者的区别。首先看传基本数据类型，如int、long等。123456789101112// 基本数据类型public class ParamChangeValue &#123; public static void main(String[] args) &#123; int s = 1; System.out.println("args = [" + s + "]"); change(s); System.out.println("args = [" + s + "]"); &#125; private static void change(int i)&#123; i = i* 5; &#125;&#125; 输出：args = [1]args = [1] 从输出的的结果中可以看到原本的s并没有被修改，即传值传递的是值的副本，不会影响到本身。 再来看传对象。1234567891011121314151617181920212223242526// 对象public class ObjectChangeValue &#123; public static class Score&#123; private int value; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125; &#125; public static void main(String[] args) &#123; Score score = new Score(); score.setValue(1); System.out.println("args = [" + score.getValue() + "]"); change(score); System.out.println("after args = [" + score.getValue() + "]"); &#125; private static void change(Score score)&#123; score.setValue(2); &#125;&#125; 输出：args = [1]after args = [2] 从结果中我们可以看到score实例的value值被修改了，因为传引用后指向的是同一个地址，修改的实际上也就是这个地址上的值，另外要注意一点的是如果对象被重新创建或赋值为null，即new会重新指向其他对象，不影响其原对象的值。 第三部分：传String、Integer等immutable类型。12345678910111213// String、Integer、Long等public class StringChangeValue &#123; public static void main(String[] args) &#123; String s = "test1"; System.out.println("args = [" + s + "]"); change(s); System.out.println("args = [" + s + "]"); &#125; private static void change(String i)&#123; i = i + " test value"; &#125;&#125; 输出：args = [test1]args = [test1] 只要知道String、Integer类是final类型的就明白输出的结果为什么是这样的。 总结基本类型（byte,short,int,long,double,float,char,boolean）为传值；对象类型（Object，数组，容器）为传引用；String、Integer、Double等immutable类型因为类的变量设为final属性，无法被修改，只能重新赋值或生成对象。当Integer作为方法参数传递时，对其赋值会导致原有的引用被指向了方法内的栈地址，失去原有的的地址指向，所以对赋值后的Integer做任何操作都不会影响原有值。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo教程</tag>
      </tags>
  </entry>
</search>
