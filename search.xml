<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java设计模式（四）：单例模式]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考链接：单例模式-Singleton Pattern 对于一个软件系统的某些类而言，我们无须创建多个实例。举个大家都熟知的例子——Windows任务管理器。 通常情况下，无论我们启动任务管理多少次，Windows系统始终只能弹出一个任务管理器窗口。为什么要这样设计呢？我们可以从以下两个方面来分析：其一，如果能弹出多个窗口，且这些窗口的内容完全一致，全部是重复对象，这势必会浪费系统资源，任务管理器需要获取系统运行时的诸多信息，这些信息的获取需要消耗一定的系统资源，包括CPU资源及内存资源等；其二，如果弹出的多个窗口内容不一致，这就意味着在某一瞬间系统资源使用情况和进程、服务等信息存在多个状态，例如任务管理器窗口A显示“CPU使用率”为10%，窗口B显示“CPU使用率”为15%，到底哪个才是真实的呢？ 1. 模式概述定义：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 下面我们来模拟实现Windows任务管理器，假设任务管理器的类名为TaskManager在TaskManager类中包含了大量的成员方法，例如构造函数TaskManager()，显示进程的方法displayProcesses()，显示服务的方法displayServices()等，该类的示意代码如下： 12345678910public class TaskManager &#123; //初始化窗口 public TaskManager() &#123; /*……*/ &#125; //显示进程 public void displayProcesses() &#123; /*……*/ &#125; //显示服务 public void displayServices() &#123; /*……*/ &#125; //其他方法 //……&#125; 为了实现Windows任务管理器的唯一性，我们通过如下三步来对该类进行重构： (1) 由于每次使用new关键字来实例化TaskManager类时都将产生一个新对象，为了确保TaskManager实例的唯一性，我们需要禁止类的外部直接使用new来创建对象，因此需要将TaskManager的构造函数的可见性改为private，代码如下所示： 1private TaskManager() &#123; /*……*/ &#125; (2) 将构造函数改为private修饰后该如何创建对象呢？我们可以在TaskManager内部创建并保存唯一实例，提供给类外部调用。为了让外界可以访问这个唯一实例，需要在TaskManager中定义一个静态的TaskManager类型的私有成员变量，代码如下所示： 1private static TaskManager tm = null; (3) 为了保证成员变量的封装性，我们将TaskManager类型的tm对象的可见性设置为private，但外界该如何使用该成员变量并何时实例化该成员变量呢？答案是增加一个公有的静态方法，代码如下所示： 123456public static TaskManager getInstance() &#123; if (tm == null) &#123; tm = new TaskManager(); &#125; return tm;&#125; 在getInstance()方法中首先判断tm对象是否存在，如果不存在（即tm == null），则使用new关键字创建一个新的TaskManager类型的tm对象，再返回新创建的tm对象；否则直接返回已有的tm对象。 需要注意的是getInstance()方法的修饰符，首先它应该是一个public方法，以便供外界其他对象使用，其次它使用了static关键字，即它是一个静态方法，在类外可以直接通过类名来访问，而无须创建TaskManager对象，事实上在类外也无法创建TaskManager对象，因为构造函数是私有的。 通过以上三个步骤，我们完成了一个最简单的单例类的设计，其完整代码如下： 12345678910111213141516171819202122public class TaskManager &#123; //初始化窗口 //public TaskManager() &#123; /*……*/ &#125; private TaskManager() &#123; /*……*/ &#125; //显示进程 public void displayProcesses() &#123; /*……*/ &#125; //显示服务 public void displayServices() &#123; /*……*/ &#125; //其他方法 //…… private static TaskManager tm = null; public static TaskManager getInstance() &#123; if (tm == null) &#123; tm = new TaskManager(); &#125; return tm; &#125;&#125; 在类外我们无法直接创建新的TaskManager对象，但可以通过代码TaskManager.getInstance()来访问实例对象，第一次调用getInstance()方法时将创建唯一实例，再次调用时将返回第一次创建的实例，从而确保实例对象的唯一性。 单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 单例模式是结构最简单的设计模式一，在它的核心结构中只包含一个被称为单例类的特殊类。单例模式结构如图所示：在单例模式结构图中只包含一个角色： Singleton（单例）：在单例类的内部实现只生成一个实例，同时提供一个静态的getInstance()方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。 2. 单例模式的多种实现2.1 饿汉式饿汉式单例类是实现起来最简单的单例类，饿汉式单例类结构图如图所示：从图中可以看出，由于在定义静态变量的时候实例化单例类，因此在类加载的时候就已经创建了单例对象，代码如下所示： 123456789101112131415public class SingletonEhs &#123; private static SingletonEhs instance = new SingletonEhs(); private SingletonEhs() &#123; &#125; public static SingletonEhs getInstance() &#123; return instance; &#125; public void showMessage() &#123; System.out.println("饿汉式单例"); &#125;&#125; 当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。 2.2 懒汉式除了饿汉式单例，还有一种经典的懒汉式单例，也就是第一章节中TaskManager实现的方式，懒汉式单例类结构图如图所示：从图中可以看出，懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Loading)技术，即需要的时候再加载实例，代码如下所示： 123456789101112131415161718public class SingletonLhsNoSyn &#123; private static SingletonLhsNoSyn instance; private SingletonLhsNoSyn() &#123; &#125; public static SingletonLhsNoSyn getInstance() &#123; if (instance == null) &#123; instance = new SingletonLhsNoSyn(); &#125; return instance; &#125; public void showMessage() &#123; System.out.println("懒汉式，线程不安全单例"); &#125;&#125; 这种方式实现起来同样很容易，但是存在一个问题，它不能保证在多线程的情况下保证只生成一个实例。为了避免多个线程同时调用getInstance()方法，我们可以使用关键字synchronized，代码如下所示： 123456789101112131415161718public class SingletonLhsSyn &#123; private static SingletonLhsSyn instance; private SingletonLhsSyn() &#123; &#125; public static synchronized SingletonLhsSyn getInstance() &#123; if (instance == null) &#123; instance = new SingletonLhsSyn(); &#125; return instance; &#125; public void showMessage() &#123; System.out.println("懒汉式，线程安全单例"); &#125;&#125; 该懒汉式单例类在getInstance()方法前面增加了关键字synchronized进行线程锁，以处理多个线程同时访问的问题。但是，上述代码虽然解决了线程安全问题，但是每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。如何既解决线程安全问题又不影响系统性能呢？接下来介绍单例的第三种实现方式–双检锁。 2.3 双检锁/双重校验锁线程安全懒汉式解决了线程安全问题但可能会影响系统性能，我们需要对其进行改进。事实上，我们无须对整个getInstance()方法进行锁定，只需对其中的代码“instance = new SingletonLhsSyn();”进行锁定即可。因此getInstance()方法可以进行如下改进： 12345678910111213141516171819202122public class SingletonDCL &#123; private static SingletonDCL instance; private SingletonDCL() &#123; &#125; public static SingletonDCL getInstance() &#123; //先检查实例是否存在，如果不存在才进入下面的同步块 if (instance == null) &#123; //同步块，线程安全的创建实例 synchronized (SingletonDCL.class) &#123; instance = new SingletonDCL(); &#125; &#125; return instance; &#125; public void showMessage() &#123; System.out.println("双检锁/双重校验锁单例"); &#125;&#125; 问题貌似得以解决，事实并非如此。如果使用以上代码来实现单例，还是会存在单例对象不唯一。原因如下：假如在某一瞬间线程A和线程B都在调用getInstance()方法，此时instance对象为null值，均能通过instance == null的判断。由于实现了synchronized加锁机制，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定代码。但当A执行完毕时，线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，因此需要进行进一步改进，在synchronized中再进行一次instance == null判断，所以这种方式被称为双重检查锁定(Double-Check Locking)。使用双重检查锁定实现的懒汉式单例类完整代码如下所示： 1234567891011121314151617181920212223242526public class SingletonDCL &#123; //对保存实例的变量添加volitile的修饰 private volatile static SingletonDCL instance; private SingletonDCL() &#123; &#125; public static SingletonDCL getInstance() &#123; //先检查实例是否存在，如果不存在才进入下面的同步块 if (instance == null) &#123; //同步块，线程安全的创建实例 synchronized (SingletonDCL.class) &#123; //再次检查实例是否存在，如果不存在才真正的创建实例 if (instance == null) &#123; instance = new SingletonDCL(); &#125; &#125; &#125; return instance; &#125; public void showMessage() &#123; System.out.println("双检锁/双重校验锁单例"); &#125;&#125; 需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理（这里要加volatile的原因以及更详细的介绍可以参考我的另一篇博客Java 并发：volatile 内存可见性和指令重排），且该代码只能在JDK 1.5及以上版本中才能正确执行。由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。 2.4 静态内部类饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全需要控制琐，而且性能受影响。这里介绍一种更好的单例实现方式–静态内部类。 我们在单例类中增加一个静态内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用，实现代码如下所示： 12345678910111213141516171819public class SingletonSIC &#123; //类级的内部类，也就是静态类的成员式内部类，该内部类的实例与外部类的实例没有绑定关系，而且只有被调用时才会装载，从而实现了延迟加载 private static class SingletonHolder &#123; //静态初始化器，由JVM来保证线程安全 private static final SingletonSIC INSTANCE = new SingletonSIC(); &#125; private SingletonSIC() &#123; &#125; public static final SingletonSIC getInstance() &#123; return SingletonHolder.INSTANCE; &#125; public void showMessage() &#123; System.out.println("静态内部类单例"); &#125;&#125; 由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类SingletonHolder，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。 这种技术被称之为Initialization Demand Holder (IoDH)的技术，通过IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）。 2.5 枚举类在Effective Java中介绍到另外一种实现单例的方式–枚举单例。相比于其它方式实现的单例，枚举单例能够保证单例不被反射破坏。枚举单例实现如下：12345678910public enum SingletonEnum &#123; INSTANCE; SingletonEnum() &#123; &#125; public void showMessage() &#123; System.out.println("枚举单例"); &#125;&#125; 这里有个概念–“反射破坏单例”，在上面介绍的方法中，我们通过将构造函数私有化保证外部不能通过new的方式创建对象实例，一般情况下确实可以保证类实例的唯一性。但是我们知道，反射可以帮助我们获取类的方法，构造函数，甚至访问私有属性。通过反射创建不同对象实例的代码如下所示： 12345678910111213141516171819202122232425public class SingleReflection &#123; @SuppressWarnings("unchecked") public static void main(String[] args) throws Exception &#123; SingletonEhs s1 = SingletonEhs.getInstance(); Class clazz = SingletonEhs.class; Constructor constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); SingletonEhs s2 = (SingletonEhs) constructor.newInstance(); SingletonEhs s3 = (SingletonEhs) constructor.newInstance(); System.out.println(s1 == s2); // false System.out.println(s1.equals(s2)); // false System.out.println(s2 == s3); // false System.out.println(s2.equals(s3)); // false //以下输出三个不同的hashcode值 System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); System.out.println(s3.hashCode()); &#125;&#125; 而当我们以同样的方式获取枚举单例类的构造函数时会报错（即使我们在枚举类中定义构造函数）： 1234Exception in thread "main" java.lang.NoSuchMethodException: cn.qianlq.singleton.object.SingletonEnum.&lt;init&gt;() at java.lang.Class.getConstructor0(Class.java:3082) at java.lang.Class.getDeclaredConstructor(Class.java:2178) at cn.qianlq.singleton.reflection.SingleReflection.main(SingleReflection.java:40) 枚举类的实质： 3. 模式总结单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。 1.主要优点(1) 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。(2) 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。(3) 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损性能的问题。 2.主要缺点(1) 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。(2) 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。(3) 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。 3.适用场景(1) 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。(2) 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 4. 思考如何对单例模式进行改造，使得系统中某个类的对象可以存在有限多个，例如两例或三例？【注：改造之后的类可称之为多例类。】]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（三）：抽象工厂模式]]></title>
    <url>%2F2019%2F03%2F08%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考链接：抽象工厂模式-Abstract Factory Pattern 工厂方法模式解决了简单工厂模式存在的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是我们本文将要学习的抽象工厂模式的基本思想。 1. 模式概述定义：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族，抽象工厂模式结构如图所示： 在抽象工厂模式中包含如下几个角色： AbstractFactory（抽象工厂）：它声明一组用于创建一族产品的方法，每一个方法对应一种产品。 ConcreteFactory（具体工厂）：它实现抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。 AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。 2. 模式实现在抽象工厂中声明多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：1234public abstract class AbstractFactory &#123; public abstract Color getColor(); public abstract Shape getShape();&#125; 具体工厂实现抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下所示：123456789101112public class BlueCircleFactory extends AbstractFactory &#123; @Override public Color getColor() &#123; return new Blue(); &#125; @Override public Shape getShape() &#123; return new Circle(); &#125;&#125; 123456789101112public class RedRectangleFactory extends AbstractFactory &#123; @Override public Color getColor() &#123; return new Red(); &#125; @Override public Shape getShape() &#123; return new Rectangle(); &#125;&#125; 与工厂方法模式一样，抽象工厂模式也可为每一种产品提供一组重载的工厂方法，以不同的方式对产品对象进行创建。 抽象工厂模式同样可以通过读取配置文件生成对应的产品，不再赘述。 3. “开闭原则”的倾斜性针对概述中的例子，如果有一个新的需求，要在抽象工厂类中添加一个工厂方法getSize()，那么我们就需要修改每个具体工厂类，实现getSize()方法，不符合“开闭原则”。 那么怎么办？答案是抽象工厂模式无法解决该问题，这也是抽象工厂模式最大的缺点。在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。 “开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面： (1) 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。 (2) 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。 正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。 4. 模式总结抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。 1.主要优点(1) 抽象工厂模式隔离了具体类的生成，由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。(2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。(3) 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 2.主要缺点增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，违背了“开闭原则”。 3.适用场景(1) 用户不关心对象的创建过程，将对象的创建和使用解耦。(2) 系统中有多于一个的产品族，而每次只使用其中某一产品族。(3) 产品等级结构稳定，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。 5. 思考抽象工厂模式是否符合“开闭原则”？【从增加新的产品等级结构和增加新的产品族两方面进行思考。】 答案已经给出。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（二）：工厂方法模式]]></title>
    <url>%2F2018%2F12%2F30%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考链接：工厂方法模式-Factory Method Pattern 在介绍简单工厂模式时提到简单工厂模式存在一个很严重的问题，就是当系统中需要引入新产品时，如果静态工厂方法是通过传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？工厂方法模式应运而生，本文将介绍第二种工厂模式——工厂方法模式。 1. 模式概述定义：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。 工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。工厂方法模式结构如图所示： 在工厂方法模式结构图中包含如下几个角色： Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类。 ConcreteProduct（具体产品）：实现抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。 Factory（抽象工厂）：抽象工厂是工厂方法模式的核心，是具体工厂的父类，声明工厂方法。 ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。 与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：1234public abstract class AbstractFactory &#123; public abstract Shape getShape();&#125; 2. 模式实现具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现工厂方法，不同的具体工厂可以创建不同的具体产品，其典型代码如下所示：1234567891011public class CircleFactory extends AbstractFactory &#123; /** * 返回具体的 Circle 实例 * @return */ @Override public Shape getShape() &#123; return new Circle(); &#125;&#125; 1234567891011public class RectangleFactory extends AbstractFactory &#123; /** * 返回具体的 Rectangle 实例 * @return */ @Override public Shape getShape() &#123; return new Rectangle(); &#125;&#125; 1234567891011public class SquareFactory extends AbstractFactory &#123; /** * 返回具体的 Square 实例 * @return */ @Override public Shape getShape() &#123; return new Square(); &#125;&#125; 在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。 在客户端代码中，只需关心工厂类即可，不同的具体工厂可以创建不同的产品，典型的客户端类代码片段如下所示：123456789public class Client &#123; public static void main(String[] args) &#123; AbstractFactory factory; factory = new CircleFactory(); Shape circle = factory.getShape(); circle.draw(); &#125;&#125; 3. 方案改进可以通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。 在客户端代码中将不再使用new关键字来创建工厂对象，而是将具体工厂类的类名存储在配置文件（如XML文件）中，通过读取配置文件获取类名字符串，再使用Java的反射机制，根据类名字符串生成对象。 在配置文件config.xml用于存储具体日志记录器工厂类类名：12345&lt;?xml version="1.0"?&gt;&lt;config&gt; &lt;!-- 具体工厂类的全限定名 包名+类名 --&gt; &lt;className&gt;RectangleFactory&lt;/className&gt;&lt;/config&gt; 创建XMLUtil类读取该配置文件并通过存储在其中的类名字符串反射生成对象，其详细代码如下：123456789101112131415161718192021222324public class XMLUtil &#123; public static Object getFactory() &#123; try &#123; DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; doc = builder.parse(new File("config.xml")); NodeList nl = doc.getElementsByTagName("className"); Node classNode = nl.item(0).getFirstChild(); String className = classNode.getNodeValue(); Class clazz = Class.forName(className); Object obj = clazz.newInstance(); return obj; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 要更换具体工厂时，通过XMLUtil类的静态方法getFactory()方法读取配置文件中的工厂类名进行对象的实例化，代码修改如下： 123456789public class Client &#123; public static void main(String[] args) &#123; AbstractFactory factory; factory = (AbstractFactory) XMLUtil.getFactory(); Shape shape = factory.getShape(); shape.draw(); &#125;&#125; 重载抽象工厂类的工厂方法可以实现多种方式初始化具体产品类，例如提供无参数的默认实现，还可以提供包含一个字符串参数的实现。 12345678public abstract class AbstractFactory &#123; public abstract Shape getShape(); public abstract Shape getShape(String args); public abstract Shape getShape(Object obj);&#125; 具体的工厂类实现重载的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同产品对象的需求。 4. 模式总结工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。 1.主要优点(1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节。(2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。(3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可，系统的可扩展性也就变得非常好，完全符合“开闭原则”。 2.主要缺点(1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度。(2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。 3.适用场景(1) 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件中。(2) 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 5. 思考有人说：可以在客户端代码中直接通过反射机制来生成产品对象，在定义产品对象时使用抽象类型，同样可以确保系统的灵活性和可扩展性，增加新的具体产品类无须修改源代码，只需要将其作为抽象产品类的子类再修改配置文件即可，根本不需要抽象工厂类和具体工厂类。 试思考这种做法的可行性？如果可行，这种做法是否存在问题？为什么？]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 设计模式（一）：简单工厂模式]]></title>
    <url>%2F2018%2F12%2F30%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考链接：简单工厂模式-Simple Factory Pattern 1. 模式概述定义：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态方法，因此简单工厂模式又被称为静态工厂方法模式。 简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下：首先将需要创建的各种不同对象（例如各种不同的Shape对象）的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。 简单工厂模式结构比较简单，其核心是工厂类的设计，其结构如图所示： 在简单工厂模式中包含如下几个角色： Factory（工厂类）：负责实现创建所有产品实例的内部逻辑，在工厂类中提供静态的工厂方法，返回抽象产品。 Product（抽象产品）：所有具体产品的父类，封装各种产品对象的共有方法。 ConcreteProduct（具体产品类）：工厂类的创建目标。 2. 模式实现在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象。 在使用简单工厂模式时，首先需要对产品类进行重构，根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：12345678public abstract class Shape &#123; // 公共方法 public void show() &#123; &#125; // 抽象方法 public abstract void draw();&#125; 具体产品类继承抽象产品类并实现抽象方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示： 1234567public class Circle extends Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 1234567public class Rectangle extends Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; 1234567public class Square extends Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; 简单工厂模式的核心工厂类负责创建产品，提供一个静态工厂方法给客户端使用，典型的工厂类代码如下所示： 12345678910111213141516public class ShapeFactory &#123; public static Shape getShape(String shapeType) &#123; if (shapeType == null) &#123; return null; &#125; if (shapeType.equalsIgnoreCase("CIRCLE")) &#123; return new Circle(); &#125; else if (shapeType.equalsIgnoreCase("RECTANGLE")) &#123; return new Rectangle(); &#125; else if (shapeType.equalsIgnoreCase("SQUARE")) &#123; return new Square(); &#125; return null; &#125;&#125; 在客户端代码中，我们通过传入不同的参数给工厂方法来创建对应的产品，典型的代码如下所示： 12345678910111213public class Client &#123; public static void main(String[] args) &#123; Shape rectangle = ShapeFactory.getShape("Rectangle"); rectangle.draw(); Shape circle = ShapeFactory.getShape("Circle"); circle.draw(); Shape square = ShapeFactory.getShape("Square"); square.draw(); &#125;&#125; 3. 方案改进当我们更换一个Shape对象都需要修改客户端代码中静态工厂方法的参数，客户端代码将要重新编译，这对于客户端而言，违反了“开闭原则”，有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？ 我们可以将静态工厂方法的参数存储在XML或properties格式的配置文件中，如下config.xml所示：1234&lt;?xml version="1.0"?&gt;&lt;config&gt; &lt;chartType&gt;square&lt;/chartType&gt;&lt;/config&gt; 在通过一个工具类XMLUtil来读取配置文件中的字符串参数，XMLUtil类的代码如下所示： 123456789101112131415161718192021public class XMLUtil &#123; public static String getChartType() &#123; try &#123; // 创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc; // config.xml的路径 doc = builder.parse(new File("config.xml")); // 获取包含图表类型的文本节点 NodeList nl = doc.getElementsByTagName("shapeType"); Node classNode = nl.item(0).getFirstChild(); String shapeType = classNode.getNodeValue().trim(); return shapeType; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 客户端通过读取配置文件中的shapeType创建对应的产品，客户端修改代码如下：12345678public class Client &#123; public static void main(String[] args) &#123; String shapeType = XMLUtil.getChartType(); Shape shape = ShapeFactory.getShape(shapeType); shape.draw(); &#125;&#125; 优化之后，如果需要更换具体图表对象，只需修改配置文件config.xml，无须修改任何源代码，符合“开闭原则”。 还有另外一种情况，当系统中需要引入新产品时，比如引入新产品Triangle，由于静态工厂方法通过所传入参数的不同来创建不同的产品，那么势必要在工厂类中新增一个if…else判断来返回Triangle实例，违背了“开闭原则”。 在工厂类中新增if…else判断的代码如下：123456789101112131415161718public class ShapeFactory &#123; public static Shape getShape(String shapeType) &#123; if (shapeType == null) &#123; return null; &#125; if (shapeType.equalsIgnoreCase("CIRCLE")) &#123; return new Circle(); &#125; else if (shapeType.equalsIgnoreCase("RECTANGLE")) &#123; return new Rectangle(); &#125; else if (shapeType.equalsIgnoreCase("SQUARE")) &#123; return new Square(); &#125; else if (shapeType.equalsIgnoreCase("TRIANGLE")) &#123; return new Triangle(); &#125; return null; &#125;&#125; 一旦产品类型较多时，工厂类会变得不易维护。 我们可以通过反射机制解加增加新产品时需要改动静态工厂方法的缺点，修改静态工厂方法代码如下：123456789public static &lt;T&gt; T getClass(Class&lt;? extends T&gt; clazz) &#123; T obj = null; try &#123; obj = (T) Class.forName(clazz.getName()).newInstance(); &#125; catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return obj;&#125; 对应的客户端通过传入具体的产品类创建不同的产品，客户端代码修改如下：1234567public class Client &#123; public static void main(String[] args) &#123; String shape = ShapeFactory.getClass(Circle.class); shape.draw(); &#125;&#125; 反射机制可以结合配置文件来更换具体的产品对象，而不需要改动客户端代码。 4. 模式总结简单工厂模式提供专门的工厂类用于创建对象，将对象的创建和对象的使用分离开。 1.主要优点(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 2.主要缺点(1) 由于工厂类集中了所有产品的创建逻辑，如果工厂类不能工作，整个系统都要受到影响。(2) 当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码（反射方式除外）。(3) 在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 3.适用场景(1) 工厂类负责创建的对象比较少时，不会造成工厂方法中的业务逻辑太过复杂，这个时候可以考虑使用简单工厂。(2) 客户端对于如何创建对象并不关心。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F12%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是设计模式设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。 面向对象设计的原则 开闭原则 (Open Close Principle) 里氏代换原则 (Liskov Substitution Principle) 依赖倒转原则 (Dependence Inversion Principle) 接口隔离原则 (Interface Segregation Principle) 单一职责原则 (Single Responsibility Principle) 4. 模式分类4.1 创建型模式 创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。 创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。 简单工厂模式 (Simple Factory Pattern)工厂方法模式 (Factory Method Pattern)抽象工厂模式 (Abstract Factory Pattern)建造者模式 (Builder Pattern)单例模式 (Singleton Pattern)原型模式 (Prototype Pattern) 4.2 结构型模式 结构型模式描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。 结构型模式可以分为类结构型模式和对象结构型模式：类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系；对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。 适配器模式 (Adapter Pattern)桥接模式 (Bridge Pattern)装饰模式 (Decorator Pattern)过滤器模式 (Filter Pattern)外观模式 (Facade Pattern)享元模式 (Flyweight Pattern)代理模式 (Proxy Pattern)组合模式 (Composite Pattern) 4.3 行为型模式 行为型模式是对在不同的对象之间划分责任和算法的抽象化。 行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 行为型模式分为类行为型模式和对象行为型模式两种：类行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责；对象行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。 命令模式 (Command Pattern)中介者模式 (Mediator Pattern)观察者模式 (Observer Pattern)状态模式 (State Pattern)策略模式 (Strategy Pattern)责任链模式 (Chain of Responsibility Pattern)解释器模式 (Interpreter Pattern)迭代器模式 (Iterator Pattern)备忘录模式 (Memento Pattern) 5. GitHub 地址design-patterns]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 循环遍历中删除元素问题二]]></title>
    <url>%2F2018%2F11%2F14%2FArrayList%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E9%97%AE%E9%A2%98%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[前言问题一可以看我之前写的博客 List 循环遍历中删除元素问题一。 问题讲解问题二主要讲的是博主在今天的开发中遇到的一个问题。先来看下是什么问题让博主继上次问题后又写了问题二。 问题一中讲到通过Iterator的remove方法解决链表中循环删除元素的问题。来看下简单的代码： 123456789101112131415161718192021public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("1"); list.add("2"); list.add("3"); list.add("4"); list.add("5"); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; String s = iterator.next(); if ("4".equals(s)) &#123; iterator.remove(); &#125; &#125; System.out.println("list:" + list); &#125;&#125; 输出：list:[1, 2, 3, 5]，成功删除元素4。 但是这种解决方法中隐藏着一个坑。在今天和前端的联调过程中发现的，我们一般从数据库查询多条数据时会返回返回List&lt;?&gt;，?表示具体的实体类，然后通过Iterator遍历List删除其中的元素，以下是类似的代码： 12345678910111213141516public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("1","2","3","4","5"); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; String s = iterator.next(); if ("4".equals(s)) &#123; iterator.remove(); &#125; &#125; System.out.println("list:" + list); &#125;&#125; 原本以为通过iterator.remove()方法能够成功删除元素，但是上述代码在控制台却报了这么一个错： 1234Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.AbstractList.remove(AbstractList.java:161) at java.util.AbstractList$Itr.remove(AbstractList.java:374) at list.ListTest.main(ListTest.java:22) 一开始感到很困惑，但是在经过自己debug之后终于发现了问题所在，debug下进入的第一个方法： 123456789101112131415public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125;&#125; 在执行到AbstractList.this.remove(lastRet);时进入下一个方法： 12345678public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; /*... 其它方法略...*/ public E remove(int index) &#123; throw new UnsupportedOperationException(); &#125;&#125; 原来此处的ArrayList是一个实现了AbstractList的内部类，并且没有覆盖add和remove方法，默认这2个方法是会直接报“UnsupportedOperationException”的。 知道问题原因后，解决方法也就明确了。 1234567891011121314151617public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("1","2","3","4","5"); List&lt;String&gt; result= new ArrayList&lt;&gt;(list); Iterator&lt;String&gt; iterator = result.iterator(); while (iterator.hasNext()) &#123; String s = iterator.next(); if ("4".equals(s)) &#123; iterator.remove(); &#125; &#125; System.out.println("list:" + result); &#125;&#125; 通过将list拷贝到一个新的ArrayList中即可解决问题二。 总结在设计一个对外方法的时候，一点要谨慎处理集合和数组。因为你永远不知道传给你的集合是什么，也不知道是否会有对此集合有任何其他的不可控的操作。所以在使用客户端传递的集合对象时，最好拷贝一个新集合后再操作。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 循环遍历中删除元素问题一]]></title>
    <url>%2F2018%2F11%2F07%2FArrayList%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E9%97%AE%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[问题抛出一个ArrayList在循环过程中删除，会不会出问题，为什么？接下来给大家详细解释一下在这个过程中会出现的问题和原因及解决方法。 问题讲解ArrayList中的remove方法（注意ArrayList中的remove有两个同名方法，只是输入参数不同，这里看的是输入参数是Object的remove方法）是怎么实现的： 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; 12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work &#125; 执行System.arraycopy方法，导致删除元素时涉及到数组元素的移动。 for each写法是对实际的Iterator、hasNext、next方法的简写，问题出在上文的fastRemove中，可以看到第一行把modCount变量的值加1，但在ArrayList返回的迭代器（该代码在其父类AbstractList中）。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; 这里返回的是AbstractList类内部的迭代器实现private class Itr implements Iterator，看这个类的next方法。 1234567891011public E next() &#123; checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; 这里会做迭代器内部修改次数检查，因为你上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。要避免这种情况的出现，则在使用迭代器迭代时（显式或for each的隐式）不要使用ArrayList的remove，改用Iterator的remove即可。 总结错误原因都是ArrayList集合中remove方法底层的源码中有一个fastRemove(index)方法，然后会有一个modCount++的操作，然后在ArratList内部的迭代器中有一个checkForComodification操作，也就是检查modCount是否改变，如果改变了，就抛出并发修改错误。同样的在For each增强for循环中，也是利用了ArrayList自身的Iterator迭代器，也是会出现这样的错误。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 传值和传引用的区别]]></title>
    <url>%2F2018%2F11%2F05%2F%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言首先对传值和传引用要有个基本的概念 传值：传递的是值的副本。方法中对副本的修改，不会影响到调用方。 传引用：传递的是引用的副本，共用一个内存，会影响到调用方。此时，形参和实参指向同一个内存地址。对引用副本本身（对象地址）的修改，如设置为null，重新指向其他对象，不会影响到调用方。 实战直接上代码，更好的理解两者的区别。首先看传基本数据类型，如int、long等。123456789101112// 基本数据类型public class ParamChangeValue &#123; public static void main(String[] args) &#123; int s = 1; System.out.println("args = [" + s + "]"); change(s); System.out.println("args = [" + s + "]"); &#125; private static void change(int i)&#123; i = i* 5; &#125;&#125; 输出：args = [1]args = [1] 从输出的的结果中可以看到原本的s并没有被修改，即传值传递的是值的副本，不会影响到本身。 再来看传对象。1234567891011121314151617181920212223242526// 对象public class ObjectChangeValue &#123; public static class Score&#123; private int value; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125; &#125; public static void main(String[] args) &#123; Score score = new Score(); score.setValue(1); System.out.println("args = [" + score.getValue() + "]"); change(score); System.out.println("after args = [" + score.getValue() + "]"); &#125; private static void change(Score score)&#123; score.setValue(2); &#125;&#125; 输出：args = [1]after args = [2] 从结果中我们可以看到score实例的value值被修改了，因为传引用后指向的是同一个地址，修改的实际上也就是这个地址上的值，另外要注意一点的是如果对象被重新创建或赋值为null，即new会重新指向其他对象，不影响其原对象的值。 第三部分：传String、Integer等immutable类型。12345678910111213// String、Integer、Long等public class StringChangeValue &#123; public static void main(String[] args) &#123; String s = "test1"; System.out.println("args = [" + s + "]"); change(s); System.out.println("args = [" + s + "]"); &#125; private static void change(String i)&#123; i = i + " test value"; &#125;&#125; 输出：args = [test1]args = [test1] 只要知道String、Integer类是final类型的就明白输出的结果为什么是这样的。 总结基本类型（byte,short,int,long,double,float,char,boolean）为传值；对象类型（Object，数组，容器）为传引用；String、Integer、Double等immutable类型因为类的变量设为final属性，无法被修改，只能重新赋值或生成对象。当Integer作为方法参数传递时，对其赋值会导致原有的引用被指向了方法内的栈地址，失去原有的的地址指向，所以对赋值后的Integer做任何操作都不会影响原有值。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo教程</tag>
      </tags>
  </entry>
</search>
