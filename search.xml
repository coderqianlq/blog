<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ArrayList 循环遍历中删除元素问题二]]></title>
    <url>%2F2018%2F11%2F14%2FArrayList%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E9%97%AE%E9%A2%98%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[前言问题一可以看我之前写的博客 List 循环遍历中删除元素问题一。 问题讲解问题二主要讲的是博主在今天的开发中遇到的一个问题。先来看下是什么问题让博主继上次问题后又写了问题二。 问题一中讲到通过Iterator的remove方法解决链表中循环删除元素的问题。来看下简单的代码： 123456789101112131415161718192021public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("1"); list.add("2"); list.add("3"); list.add("4"); list.add("5"); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; String s = iterator.next(); if ("4".equals(s)) &#123; iterator.remove(); &#125; &#125; System.out.println("list:" + list); &#125;&#125; 输出：list:[1, 2, 3, 5]，成功删除元素4。 但是这种解决方法中隐藏着一个坑。在今天和前端的联调过程中发现的，我们一般从数据库查询多条数据时会返回返回List&lt;?&gt;，?表示具体的实体类，然后通过Iterator遍历List删除其中的元素，以下是类似的代码： 12345678910111213141516public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("1","2","3","4","5"); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; String s = iterator.next(); if ("4".equals(s)) &#123; iterator.remove(); &#125; &#125; System.out.println("list:" + list); &#125;&#125; 原本以为通过iterator.remove()方法能够成功删除元素，但是上述代码在控制台却报了这么一个错： 1234Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.AbstractList.remove(AbstractList.java:161) at java.util.AbstractList$Itr.remove(AbstractList.java:374) at list.ListTest.main(ListTest.java:22) 一开始感到很困惑，但是在经过自己debug之后终于发现了问题所在，debug下进入的第一个方法： 123456789101112131415public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125;&#125; 在执行到AbstractList.this.remove(lastRet);时进入下一个方法： 12345678public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; /*... 其它方法略...*/ public E remove(int index) &#123; throw new UnsupportedOperationException(); &#125;&#125; 原来此处的ArrayList是一个实现了AbstractList的内部类，并且没有覆盖add和remove方法，默认这2个方法是会直接报“UnsupportedOperationException”的。 知道问题原因后，解决方法也就明确了。 1234567891011121314151617public class ListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("1","2","3","4","5"); List&lt;String&gt; result= new ArrayList&lt;&gt;(list); Iterator&lt;String&gt; iterator = result.iterator(); while (iterator.hasNext()) &#123; String s = iterator.next(); if ("4".equals(s)) &#123; iterator.remove(); &#125; &#125; System.out.println("list:" + result); &#125;&#125; 通过将list拷贝到一个新的ArrayList中即可解决问题二。 总结在设计一个对外方法的时候，一点要谨慎处理集合和数组。因为你永远不知道传给你的集合是什么，也不知道是否会有对此集合有任何其他的不可控的操作。所以在使用客户端传递的集合对象时，最好拷贝一个新集合后再操作。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList 循环遍历中删除元素问题一]]></title>
    <url>%2F2018%2F11%2F07%2FArrayList%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E4%B8%AD%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E9%97%AE%E9%A2%98%E4%B8%80%2F</url>
    <content type="text"><![CDATA[问题抛出一个ArrayList在循环过程中删除，会不会出问题，为什么？接下来给大家详细解释一下在这个过程中会出现的问题和原因及解决方法。 问题讲解ArrayList中的remove方法（注意ArrayList中的remove有两个同名方法，只是输入参数不同，这里看的是输入参数是Object的remove方法）是怎么实现的： 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; 12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work &#125; 执行System.arraycopy方法，导致删除元素时涉及到数组元素的移动。 for each写法是对实际的Iterator、hasNext、next方法的简写，问题出在上文的fastRemove中，可以看到第一行把modCount变量的值加1，但在ArrayList返回的迭代器（该代码在其父类AbstractList中）。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; 这里返回的是AbstractList类内部的迭代器实现private class Itr implements Iterator，看这个类的next方法。 1234567891011public E next() &#123; checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; 这里会做迭代器内部修改次数检查，因为你上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。要避免这种情况的出现，则在使用迭代器迭代时（显式或for each的隐式）不要使用ArrayList的remove，改用Iterator的remove即可。 总结错误原因都是ArrayList集合中remove方法底层的源码中有一个fastRemove(index)方法，然后会有一个modCount++的操作，然后在ArratList内部的迭代器中有一个checkForComodification操作，也就是检查modCount是否改变，如果改变了，就抛出并发修改错误。同样的在For each增强for循环中，也是利用了ArrayList自身的Iterator迭代器，也是会出现这样的错误。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 传值和传引用的区别]]></title>
    <url>%2F2018%2F11%2F05%2F%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言首先对传值和传引用要有个基本的概念 传值：传递的是值的副本。方法中对副本的修改，不会影响到调用方。 传引用：传递的是引用的副本，共用一个内存，会影响到调用方。此时，形参和实参指向同一个内存地址。对引用副本本身（对象地址）的修改，如设置为null，重新指向其他对象，不会影响到调用方。 实战直接上代码，更好的理解两者的区别。首先看传基本数据类型，如int、long等。123456789101112// 基本数据类型public class ParamChangeValue &#123; public static void main(String[] args) &#123; int s = 1; System.out.println("args = [" + s + "]"); change(s); System.out.println("args = [" + s + "]"); &#125; private static void change(int i)&#123; i = i* 5; &#125;&#125; 输出：args = [1]args = [1] 从输出的的结果中可以看到原本的s并没有被修改，即传值传递的是值的副本，不会影响到本身。 再来看传对象。1234567891011121314151617181920212223242526// 对象public class ObjectChangeValue &#123; public static class Score&#123; private int value; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125; &#125; public static void main(String[] args) &#123; Score score = new Score(); score.setValue(1); System.out.println("args = [" + score.getValue() + "]"); change(score); System.out.println("after args = [" + score.getValue() + "]"); &#125; private static void change(Score score)&#123; score.setValue(2); &#125;&#125; 输出：args = [1]after args = [2] 从结果中我们可以看到score实例的value值被修改了，因为传引用后指向的是同一个地址，修改的实际上也就是这个地址上的值，另外要注意一点的是如果对象被重新创建或赋值为null，即new会重新指向其他对象，不影响其原对象的值。 第三部分：传String、Integer等immutable类型。12345678910111213// String、Integer、Long等public class StringChangeValue &#123; public static void main(String[] args) &#123; String s = "test1"; System.out.println("args = [" + s + "]"); change(s); System.out.println("args = [" + s + "]"); &#125; private static void change(String i)&#123; i = i + " test value"; &#125;&#125; 输出：args = [test1]args = [test1] 只要知道String、Integer类是final类型的就明白输出的结果为什么是这样的。 总结基本类型（byte,short,int,long,double,float,char,boolean）为传值；对象类型（Object，数组，容器）为传引用；String、Integer、Double等immutable类型因为类的变量设为final属性，无法被修改，只能重新赋值或生成对象。当Integer作为方法参数传递时，对其赋值会导致原有的引用被指向了方法内的栈地址，失去原有的的地址指向，所以对赋值后的Integer做任何操作都不会影响原有值。]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo教程</tag>
      </tags>
  </entry>
</search>
